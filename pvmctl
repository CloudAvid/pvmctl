#!/bin/sh
#
# Wrapper script to manage KVM virtual machines.
# Licensed using the 2-clause BSD license (below)
#
# Copyright 2009 Freddie Cash
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer
#    in the documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY FREDDIE CASH ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FREDDIE CASH BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

. /etc/pvm.conf

# The file to use as a template when creating new VM configs
template="$basedir/Scripts/template.pvm"

# Default ifup script
defifup="$basedir/Scripts/pvm-ifup"

# Vlan ifups Prefix
vlanifup="$basedir/Scripts/ifup-vlan"

#  Adjust these as needed.  These are the min and max amount
#+ of RAM to assign to a VM, in MB
minmem="128"
maxmem="16384"

# How long to sleep at certain points in the script
sleeptime="3"


# What are we called?
scriptname=$( ${basename} $0 )
scriptversion="2.0"

# Functions used in the script
load_defaults()
{
	# How much RAM to associate with the VM.
	defmem="512"

	# The number of virtual CPUs to assign to the VM.
	# Stable values are 1-4
	defcpus="1"

	# Which mouse device to use
	# Values:  mouse, tablet
	defmouse="tablet"

	# The network chipset to use in the VM.
	# Values:  rtl1389, e1000, virtio
	defnic="virtio"

	# Which virtual block device to boot from
	# Values:  a=floppy0, b=floppy1, c=disk0, d=disk1/disk2
	defboot="c"

	# Values  for disktype: ide, scsi, virtio
	defdisktype="ide"

	# Values  for media: disk, cdrom
	defmedia="disk"

	# Values for acpi:  no, "blank"
	# no disables ACPI support in the VM
	defacpi=""
}

load_configfile()
{
	# suck in the content of config file
	if [ -r ${confdir}/${1}.pvm ]; then
		. ${confdir}/${1}.pvm

		for __i in $( read_config_file "$cf_VMStorages" ); do
			__id=`echo $__i | cut -s -d ";" -f 1`;
			if [[ $__id -eq $sid ]]; then
				__path=`echo $__i | cut -s -d ";" -f 2`;
				vmdir="$__path"
			fi
		done
	fi
}

check_host()
{
	# Check if a VM host name was given on the commandline
	if [ -z "${1}" ]; then
		echo "Error: Missing host to work on."
		exit 1
	fi

	# Check if the host name given corresponds to a configured VM
	if [ ! -e ${confdir}/${1}.pvm ]; then
		echo "Error: The host you want to manage (${1}) doesn't exist. "
		exit 1
	fi
}

do_start()
{
	# Check if a virtual host was given on the commandline
	# Will exit if none was given
	check_host "${1}"

	# Load the default values for all the config options
	load_defaults "${1}"

	# Try to load the config file for the named host
	# Will exit if the config file doesn't exist
	load_configfile "${1}"

	# Check status of the host
	${0} status ${1} > /dev/null
	if [[ $? -eq "0" ]]; then
		# If he is running, all is ok, just exit with 0.
		echo "Host is running right now ..."
		exit 0
	fi

	# Check that an ID is set
	if [ -z ${id} ]; then
		echo "Error: ID number for this host has not been set."
		exit 1
	fi

	# Set host name to config file name
	host="${1}"

	#  This variables defines the index of the first disk in each category.
	#  We use index 2 for first cdrom, to achive better performance.
	cd_index="2" #cdrom
	ide_index="0"
	scsi_index="0"
	virtio_index="0"
	
	# Number of virtual drives
	no_vdisk="${#disk[@]}"
	# Number of processed virtula drives
	np_vdisk=0
	
	for (( i = 0; "$np_vdisk" < "$no_vdisk"; ++i)); do
		# Jump from NULL elements
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		np_vdisk=$(( ++np_vdisk ))

		# Check if is there any disk string
		disk="${disk[i]}"
		if [[ -z "$disk" ]]; then 
			continue
		fi

		# Check what kind of media to use for the virtual drive
		case "${media[i]}" in
			disk)
				media="disk"
				;;
			cdrom)
				media="cdrom"
				;;
			*)
				echo "Error: Bad media type for disk($i)."
				exit 1
				;;
		esac

		#  Check if disk path is Absolute? if not, 
		#+ prepend defined pathes to disk.
		if [[ $(expr ${disk} : '/') -eq 0 ]]; then
			case "$media" in
			disk) disk="${vmdir}/${host}/${disk}" ;;
			cdrom) disk="${isodir}/${disk}" ;;
			esac
		fi

		#  Check existance of the disk..
		if [[ ! -e "$disk" ]]; then
			echo "Error: disk($i) doesn't exist or isn't readable ($disk)."
			exit 1
		fi

		extboot=""
		# Determine type of the disk
		case "${disktype[i]}" in
			ide)
				disktype="ide"

				# define index of ide disk in complex of disks and cdroms
				case "$media" in
				disk) index="$ide_index" 
					ide_index=$(( ++ide_index ))
					# NOTE: index 2 is reserved for cdroms
					if (( $ide_index == "2" )); then
						if (( $cd_index != 2 )); then
							ide_index=$cd_index
						else
							ide_index=$(( ++ide_index ))
						fi
					fi
					;;
				cdrom)
					if (( $cd_index != 2 && $ide_index >= $cd_index )); then
						index="$ide_index"
						ide_index=$(( ++ide_index ))
					else
						index="$cd_index"
						cd_index=$(( ++cd_index ))
					fi
					;;
				esac
				;;
			virtio)
				disktype="virtio"
				index="$virtio_index"
				if [[ $index = "0" && $ide_index = 0 ]]; then
					extboot=",boot=on"
				fi

				virtio_index=$(( ++virito_index ))
				;;
			scsi)
				disktype="scsi"
				index="$scsi_index"
				if [[ $index = "0" && $ide_index = "0" && $virtio_index = "0" ]]; then
					extboot=",boot=on"
				fi

				scsi_index=$(( ++scsi_index ))
				;;
			*)
				echo "Error: Bad disk type for disk($i)."
				exit 1
				;;
		esac


		# Build the drive entry that will be passed to kvm
		drives="$drives -drive index=$index,media=$media,if=${disktype}${extboot},file=${disk}"
	done

	if [[ ($ide_index -eq 0) && ($virtio_index -eq 0) && ($scsi_index -eq 0) ]]; then
		echo "Error: there isn't any boot device(disk) ..."
		exit 1
	fi

	# Set Monitoring to telnet
	confmonitor="unix:$mondir/${host},server,nowait,nodelay";
	# Check which device to boot from
	if [ ! -z ${boot} ]; then
		case "${boot}" in
			a)
				confboot="a"
				;;
			b)
				confboot="b"
				;;
			c)
				confboot="c"
				;;
			d)
				confboot="d"
				;;
			*)
				confboot=${defboot}
				;;
		esac
	fi

	# Check which virtual NIC chipset to use
	case "${nic}" in
		rtl8139)
			confnic="rtl8139"
			;;
		e1000)
			confnic="e1000"
			;;
		virtio)
			confnic="virtio"
			;;
		*)
			confnic=${defnic}
			;;
	esac

	# Make ethernet cards
	# Number of Ethernet Cards
	no_eths="${#vlan[@]}"
	# Number of Processed Ethernet Cards
	np_eths=0
	for (( i =0; $np_eths < $no_eths; ++i)); do
		if [[ ${vlan[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_eths=$(( ++np_eths ))

		eth_script="$defifup"
		if [[ ! -z "${vlan[i]}" ]]; then
			if [[ $(expr ${vlan[i]} : '/') -eq 0 ]]; then
				eth_script="$vlanifup${vlan[i]}"
			else
				# vlan[i] contains full path to the eth. script
				eth_script="${vlan[i]}"
			fi
		fi
		if [[ ! -x "$eth_script" ]]; then
			echo "Error: ethernet script \"$eth_script\" is not executable"
			exit 1
		fi
		confnet=" $confnet -net nic,macaddr=${macaddr[i]},vlan=$i,model=${confnic} \
				-net tap,vlan=$i,ifname=vm${id}$i,script=$eth_script"
	done

	# Check which virtual mouse chipset to use
	case "${mouse}" in
		mouse)
			confmouse="mouse"
			;;
		tablet)
			confmouse="tablet"
			;;
		*)
			confmouse=${defmouse}
			;;
	esac

	# Check whether to disable ACPI
	case "${acpi}" in
		no)
			confacpi="-no-acpi"
			;;
		*)
			confacpi=${defacpi}
			;;
	esac

	# Check number of virtual CPUs to use
	case "${cpus}" in
		1)
			confcpus="1"
			;;
		2)
			confcpus="2"
			confacpi=${defacpi}
			;;
		3)
			confcpus="3"
			confacpi=${defacpi}
			;;
		4)
			confcpus="4"
			confacpi=${defacpi}
			;;
		*)
			confcpus=${defcpus}
			confacpi=${defacpi}
			;;
	esac

	# Check amount of RAM to be assigned to the VM
	if [ ${mem} -lt ${minmem} -o ${mem} -gt ${maxmem} ]; then
		echo "Warning: Virtual RAM is not between ${minmem} and ${maxmem}.  Setting virtual RAM to ${defmem}."
		confmem=${defmem}
	else
		confmem=${mem}
	fi

	# Check for host-usb device
	if [[ ! -z ${host_usb1} ]]; then
		confusb1="-usbdevice host:${host_usb1}"
	fi

	# Start the VM
	echo "Attempting to start VM for ${1} ..."
	${kvm} \
		-name ${host} \
		-smp ${confcpus} \
		-m ${confmem} \
		-vnc :${id} \
		-daemonize \
		-localtime \
		-usb \
		-usbdevice ${confmouse} \
		$confnet \
		-pidfile ${piddir}/${host}.pid \
		-boot ${confboot} \
		-monitor ${confmonitor} \
		${confusb1} \
		${confacpi} \
		${drives} 
	# check if the vm is running?
	if [[ $? -eq 1 ]]; then
		echo "Error: VM for ${1} doesn't start"
		exit 1
	fi
        # Reset the permissions on the PID file
	if [ -e ${piddir}/${host}.pid ]; then
		${chmod} 644 ${piddir}/${host}.pid
	else
		echo "Error creating the PID file.  VM is running, though."
	fi

	echo "VM for ${1} has started."

	# Show the VNC port assigned to the VM.
	do_whichvnc "${1}"
}

do_stop()
{
	# Check if a virtual host was given on the commandline
	# Will exit if none was given
	check_host "${1}"

	${0} status ${1} > /dev/null
	if [[ $? -eq "1" ]]; then
		exit 0
	fi

	echo "Attempting to stop VM for ${1} ..."
	if [ -r ${piddir}/${1}.pid ]; then
		${kill} -TERM $( ${cat} ${piddir}/${1}.pid )

		${sleep} ${sleeptime}

		if [ -d /proc/$( ${cat} ${piddir}/${1}.pid ) ]; then
			echo "Warning: Something is wrong ... couldn't stop the VM."
			#do_forcekill "${1}"
			# hm.t. changed for cluster environment
			${pkill} -f -- "-name ${1}"
		fi

		${rm} ${piddir}/${1}.pid
	else
		echo "Warning: PID file missing or not readable."
		#do_forcekill "${1}"
		${pkill} -f -- "-name ${1}"
	fi

	echo "VM for ${1} has stopped."
}

do_forcekill()
{
	echo -n "Do you want to forcibly kill the KVM process for ${1}? (y/n) "
	read yesno
	case "${yesno}" in
		[yY]*)
			${pkill} -f -- "-name ${1}"
			;;
		*)
			echo "Not stopping the VM for ${1}."
			exit 0
			;;
	esac
}

do_status()
{
	if [ -z ${1} ]; then
		# Called with blank argument, show just the names of the running VMs
		echo "The following VMs are running:"
		${pgrep} -lf qemu-kvm | ${grep} -v ${scriptname} | ${awk} '{ print $4 }'
	elif [ ${1} = "kvm" ]; then
		# Called with "kvm" argument, show full details of all kvm processes
		echo "The following VMs are running:"
		${pgrep} -lf qemu | ${grep} -v ${scriptname}
	elif [ -e ${confdir}/${1}.pvm ]; then
		# Called with a VM host name, show details for just that kvm process
		${pgrep} -lf -- "-name ${1} " | ${grep} -v ${scriptname} > /dev/null
		if [ $? -eq 1 ]; then
			echo "VM for ${1} is not running"
			exit 1
		else
			echo "VM for ${1} is running"
			exit 0
		fi
	else
		echo "Error: Don't understand the command."
		echo ""
		do_usage
		exit 1
	fi
}

do_usage()
{
	${cat} <<-end-of-help
	${scriptname} ${scriptversion}
	Licensed under BSDL
	Copyright 2010

	${scriptname} is a management and control script for KVM-based virtual machines.

	Usage:  ${scriptname} start    host    - start the named VM
	        ${scriptname} startvnc host    - start the named VM, and then connect to console via VNC

	        ${scriptname} shutdown host    - send shutdown signal to VM
	        ${scriptname} reset    host    - send reset signal to VM

	        ${scriptname} stop     host    - stop  the named VM (only use if the guest is hung)
	        ${scriptname} restart  host    - stop and then start the named VM (only use if the guest is hung)

	        ${scriptname} vnc      host    - connect via VNC to the console of the named VM
	        ${scriptname} whichvnc host    - show which VNC display port is assigned to the named VM
	        ${scriptname} killvnc  host    - kills any running vncviewer processes attached to the named VM

	        ${scriptname} edit     host    - open config file for host using \$EDITOR, or create a new config file based on a template

	        ${scriptname} status           - show the names of all running VMs
	        ${scriptname} status   kvm     - show full details for all running kvm processes
	        ${scriptname} status   host    - show full details for the named kvm process

	        ${scriptname} snaps    host                        - show all snapshots of the host
	        ${scriptname} mksnap   host  [tag|id]              - make an snapshot with [tag|id] if given, or not a new
	        ${scriptname} ldsnap   host   tag|id               - load snapshot with tag|id
	        ${scriptname} rmsnap   host   tag|id               - remove snapshot with tag|id

	        ${scriptname} mkimg    host image_name image_size  - create a disk image in the host directory
	        ${scriptname} mkbimg   host base_image image_name  - create a disk image base on "base_image" in the host directory

	        ${scriptname} info     host                        - print out host information (parameters in config file)
	        ${scriptname} rmvm     host                        - delete files(config/images) of virtual machine
	        ${scriptname} rename   host   new_name             - rename host to new_name
	        ${scriptname} clone    host   clone_name clone_id  - creating a clone from the host
	
	        ${scriptname} create   template host_name host_id  - Create A virtual machine from template

	        ${scriptname} mkbase   host  [base-name]           - Create A virtual Template(base image) from host
	        ${scriptname} rmbase   base_name                   - Remove the Virtual Templae (base image) 
	        ${scriptname} mkiso    iso_name                    - Create An ISO image from the CD in Local CDROM(local)
	        ${scriptname} rmiso    iso_name                    - Remove the ISO image

	        ${scriptname} ls                                   - print out list of virtual machines
	        ${scriptname} lst                                  - print out list of Virtual Templates 
	        ${scriptname} lscd                                 - print out list of CD Images (ISO files)

	        ${scriptname} help                                 - show this usage

	** Using stop is the same as pulling the power cord on a physical system. Use with caution.

	end-of-help
}

do_whichvnc()
{
	# Check if a virtual host was given on the commandline
	# Will exit if none was given
	check_host ${1}

	echo -n "The VNC port for ${1} is "
	${pgrep} -lf -- "-name ${1} " | ${grep} -v ${scriptname} | ${awk} '{ print $10 }'
}

do_vnc()
{
	if [ ${UID} -eq 0 ];then
		echo -n "Do you really want to run vncviewer as root? (y/n) "
		read yesno
		case "${yesno}" in
			[yY]*)
				break
				;;
			*)
				exit 1
				;;
		esac
	fi

	${vncviewer} localhost$( ${pgrep} -lf -- "-name ${1}" | ${grep} -v ${scriptname} | ${awk} '{ print $10 }' ) > /dev/null 2>&1 &
}

do_killvnc()
{
	# Check if a virtual host was given on the commandline
	# Will exit if none was given
	check_host ${1}

	# Get the VNC port used by the VM
	vncport=$( ${pgrep} -lf -- "-name ${1}" | ${grep} -v ${scriptname} | ${awk} '{ print $10 }' ) 

	echo -n "Do you really want to kill the vncviewer for ${1}? (y/n) "
	read yesno
	case "${yesno}" in
		[yY]*)
			# Kill the associated vncviewer process
			${pkill} -f -- "localhost${vncport}"
			echo "vncviewer process for ${1} has been terminated."
			;;
		*)
			exit 0
			;;
	esac
}

check_uid()
{
	# If not being run as root, try to use sudo for start/stop
	if [ ${UID} -ne 0 ]; then
		cat="${sudo} ${cat}"
		chmod="${sudo} ${chmod}"
		kvm="${sudo} ${kvm}"
		kill="${sudo} ${kill}"
		pkill="${sudo} ${pkill}"
		rm="${sudo} ${rm}"
	fi
}

do_shutdown()
{
	if [[ -z ${1} ]]; then
		echo "usage: shutdown host";
		exit 1;
	fi
	check_host ${1}
	HOST=$1

	echo "system_powerdown" | $socat - UNIX-CONNECT:$mondir/$HOST > /dev/null
	echo "Shutdown signal sent to ${1} ... "
}

do_reset()
{
	if [[ -z ${1} ]]; then
		echo "usage: reset host";
		exit 1;
	fi
	check_host ${1}
	HOST=$1

	echo "system_reset" | $socat - UNIX-CONNECT:$mondir/$HOST > /dev/null
	echo "reset signal sent to ${1} ... "
}

do_mkimg()
{
	if [[ -z ${1} || -z ${2} || -z ${3} ]]; then
		echo "usage: mkimg host image_name image_size(M|G)";
		exit 1;
	fi
	check_host ${1}
	load_configfile "${1}"

	if [ -e "$vmdir/${1}" ]; then
		$kvmimg create -f qcow2 "$vmdir/${1}/${2}" "${3}"
	else
		echo "directory: $vmdir/${1} doesn\'t exist"
	fi
}

do_mkbimg()
{
	if [[ -z ${1} || -z ${2} || -z ${3} ]]; then
		echo "usage: mkbimg host base_image image_name";
		exit 1;
	fi
	check_host ${1}
	load_configfile "${1}"

	_bimg="${2}"
	if [[ $(expr ${2} : '/') -eq 0 ]]; then
		_bimg="${bidir}/${2}"
	fi

	if [ -e "$vmdir/${1}" ]; then
		${kvmimg} create -b  "${_bimg}" -f qcow2 "${vmdir}/${1}/${3}"
	else
		echo "directory: ${vmdir}/${1} doesn\'t exist"
	fi
}

do_snaps()
{
	if [[ -z ${1} ]]; then
		echo "usage: snaps host";
		exit 1;
	fi
	check_host ${1}
	load_configfile "${1}"
	HOST=$1

	echo "${1} snapshots:"
	echo "info snapshots" | $socat - UNIX-CONNECT:$mondir/$HOST | $sed -e "1,2d" -e "\$d" 
}

do_mksnap()
{
	if [[ -z ${1} ]]; then
		echo "usage: mksnap host [tag|id]";
		exit 1;
	fi
	check_host ${1}
	HOST=$1

	echo "Make an snapshot for ${1}"
	echo "Please wait ..."
	echo "savevm ${2}" |  $socat - UNIX-CONNECT:$mondir/$HOST  > /dev/null 
	echo "The Snapshot is created"
}

do_ldsnap()
{
	if [[ -z ${1} || -z ${2} ]]; then
		echo "usage: ldsnap host tag|id";
		exit 1;
	fi
	check_host ${1}
	load_configfile "${1}"
	HOST=$1

	echo "Load snapshot for ${1} with tag|id=${2}"
	echo "Please wait ..."
	echo "loadvm ${2}" | $socat - UNIX-CONNECT:$mondir/$HOST  > /dev/null 
}

do_rmsnap()
{
	if [[ -z ${1} || -z ${2} ]]; then
		echo "usage: rmsnap host tag|id";
		exit 1;
	fi
	check_host ${1}
	HOST=$1

	echo "delete snapshot from ${1} with tag|id=${2}"
	echo "please wait ..."
	echo "delvm ${2}" | $socat - UNIX-CONNECT:$mondir/$HOST > /dev/null 
}

do_mon()
{
	if [[ -z ${1} ]]; then
		echo "usage: mon host";
		exit 1;
	fi
	check_host ${1}	
	HOST=$1

	$socat - UNIX-CONNECT:$mondir/$HOST  
}

do_ls()
{
	echo "list of installed hosts:"
	echo "------------------------"
	for I in `ls ${confdir}`; do
		echo "${I%.pvm}"
	done
}

do_ls_ids()
{
	printf "%-20s%s\n" "host" "id"
	printf "%-20s%s\n" "----" "--"
	for I in `ls ${confdir}`; do
		_out="$_out${I%.pvm} "
		_id=$($sed -n -e "/^id=\".*\"/p" "${confdir}/${I}" | cut -d "=" -f 2)
		_id=${_id%\"}
		_id=${_id#\"}
		_out="$_out$_id\n"
	done
	echo -e "$_out" | awk '\
		{
			sort = "sort -k 2nr" 
			printf "%-20s%d\n", $1, $2|sort 
		}' | $sed -e "$ d"
}

do_lst()
{
	echo "list of virtual machines templates:"
	echo "-----------------------------------"
	for I in `ls ${bidir}`; do
		_conf=`expr match "$I" ".*.pvm"`
		if [[ $_conf -eq 0 ]]; then
			echo "$I"
		fi
	done
}

do_lscd()
{
	echo "list of CD Images (ISO files):"
	echo "------------------------------"
	for I in `ls ${isodir}`; do
		echo "$I"
	done
}

do_mkiso()
{
	if [[ -z "$1" ]]; then
		echo "usage: mkiso iso_name"
		exit 1
	fi

	_iso="$1"
	if [[ $(expr $1 : '/') -eq "0" ]]; then
		_iso="$isodir/$1"
	fi

	if [[ -f "$_iso" ]]; then
		echo -n "Target File exist ... Replace it (y/*)? "
		read yesno

		case $yesno in
			[yY]*)
				;;
			*)
				exit 0
				;;
		esac
	fi

	$dd if="/dev/cdrom" of="$_iso"
	exit $?
}

do_rmiso()
{
	if [[ -z "$1" ]]; then
		echo "usage: rmiso iso_name"
		exit 1
	fi

	_iso="$1"
	if [[ $(expr $1 : '/') -eq "0" ]]; then
		_iso="$isodir/$1"
	fi

	if [[ -f "$_iso" ]]; then
		echo -n "Delete \"$1\", Are you sure (y/*)? "
		read yesno

		case $yesno in
			[yY]*)
				$rm -v "$_iso"
				exit $?
				;;
			*)
				exit 0
				;;
		esac
	fi

	echo "There isn't any "ISO" with this name !!!"
	exit 1
	
}

check_run()
{
	${0} status ${1} > /dev/null
	if [[ $? -eq "0" ]]; then
		echo "your host($1) is running ..."
		echo "shutdown the host before any work ..."
		exit 1
	fi
}

do_rmvm()
{
	if [[ -z ${1} ]]; then
		echo "usage: rmvm host";
		exit 1;
	fi
	check_host ${1}
	check_run ${1}
	load_configfile "${1}"

	echo -n "remove ${1}: Are you sure (y/*)? "
	read yesno

	case $yesno in
		[yY]*)
			rm -v "$confdir/${1}.pvm"
			rm -frv "$vmdir/${1}"  
			echo "${1} removed ..."
			exit 0
			;;
		*)
			exit 1
	esac
}

do_info()
{
	if [[ -z ${1} ]]; then
		echo "usage: info host";
		exit 1;
	fi
	check_host ${1}

	cat $confdir/${1}.pvm | $sed -e "/^#/d" -e "/^$/d" \
		-e "/disktype/i\----------" \
		-e "/has2eth/i\----------"
}


do_rename()
{
	if [[ -z ${1} || -z ${2} ]]; then
		echo "usage: rename host new-name";
		exit 1;
	fi	
	check_host ${1}
	check_run ${1}
	load_configfile "${1}"

	if [[ -f "$confdir/${2}.pvm" ]]; then
		echo "Error: New Machine Exists right now !!."
		exit 1
	fi

	echo "Generating config file ..."
	$sed -e "s/${1}/${2}/g" \
			"$confdir/${1}.pvm" > "$confdir/${2}.pvm" && rm -v "$confdir/${1}.pvm"

	mv $vmdir/${1} $vmdir/${2}
	for i in `ls $vmdir/${2}/`; do
		ir=${i/${1}/${2}}
		if [[ $i != $ir ]]; then
			mv -v $vmdir/${2}/$i $vmdir/${2}/$ir
		fi
	done
		
	echo "${1} renamed to ${2}"
	echo "check ${2} config file for spacial changes"
}

#  This functio verifyes Ethernet Cards for any change in them and 
#+ Generate new MACaddresses if required.
#  Usage: review_eths host
verify_eths()
{
	# unset before loaded arrays
	unset vlan
	unset macaddr

	load_configfile "${1}"

	# Number Of ethernet cards
	no_eths=${#vlan[@]}
	# Number Of Processed ethernet cards
	np_eths=0

	_any_change=0
	for ((_i=0; $np_eths < $no_eths; ++_i)); do
		if [[ ${vlan[_i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_eths=$(( ++np_eths ))

		if [[ -z ${macaddr[_i]} ]]; then
			macaddr[_i]=$($macgen)
			_any_change="1"
		fi
	done

	if [[ $_any_change -eq "0" ]]; then
		# there is no change in ethernet cards, so exit happy
		return 0
	fi
	# Modify Config File
	_tmp_conf="/tmp/__pvmctl_$RANDOM"
	$sed -i -e "/macaddr\[.*\]=\".*\"/d" "${confdir}/${1}.pvm" 
	# Number of MAC Addresses
	no_macs=${#macaddr[@]}
	# Number of Processed MAC Addresses
	np_macs="0"
	for ((_i=0; $np_macs < $no_macs; ++_i)); do
		if [[ ${macaddr[_i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		np_macs=$(( ++np_macs ))

		if [[ ! -z ${macaddr[_i]} ]]; then
			echo "macaddr[$_i]=\"${macaddr[_i]}\"" >>  "${confdir}/${1}.pvm" 
		fi
	done
	return 0
}

do_clone()
{
	if [[ -z ${1} || -z ${2} || -z ${3} ]]; then
		echo "usage: clone host clone-name clone-id";
		exit 1;
	fi	
	check_host ${1}
	check_run ${1}
	load_configfile "${1}"

	echo "Generating config file ..."
	$sed -e "s/^id=\".*\"/id=\"${3}\"/" \
		-e "s/${1}/${2}/g" \
		-e "/macaddr\[.*\]=\".*\"/d" $confdir/${1}.pvm > $confdir/${2}.pvm

	echo "Creating disks, please wait ..."
	mkdir "$vmdir/${2}"
	for i in `ls $vmdir/${1}/`; do
		ic=${i/${1}/${2}}
		cp -v $vmdir/${1}/$i $vmdir/${2}/$ic
	done

	verify_eths "${2}"
	echo "clone(${2}) created ... "
}

do_edit()
{
	# If the config file exists, and is writable by the user, then load it using $EDITOR
	if [ -e ${confdir}/${1}.pvm ]; then
		if [ -w ${confdir}/${1}.pvm ]; then
			${EDITOR} ${confdir}/${1}.pvm

			# test existance of "VM" directory
			# if doesn't exist, create him.
			load_configfile "$1"
			if [[ ! -d "$vmdir/$1" ]]; then
				$mkdir "$vmdir/$1"
			fi
		else
			echo "Error: You don't have write permission for ${confdir}/${1}.pvm"
			exit 1
		fi
	else
		echo -n "${confdir}/${1}.pvm does not exist.  Would you like to create one from the template? (y/n) "
		read yesno
		case "${yesno}" in
			[yY]*)
				if [ -r ${template} ]; then
					if [ -w ${confdir} ]; then
						$cp ${template} "${confdir}/${1}.pvm" > "/dev/null" 
						${EDITOR} ${confdir}/${1}.pvm

						load_configfile "${1}"
						$mkdir $vmdir/${1}

						echo "put your virtual machine images in $vmdir/${1}"
					else
						echo "Error: You don't have write permission for ${confdir}"
						exit 1
					fi
				else
					echo "Error: The template config file (${template}) doesn't exist or isn't readable."
					exit 1
				fi
				;;
			*)
				echo "As you wish."
				exit 1
				;;
		esac
	fi
	verify_eths "${1}"
}

do_mkbase()
{
	if [[ -z "$1" ]]; then
		echo "usage: mkbase host [base_name]"
		exit 1
	fi
	check_host ${1}
	check_run ${1}
	load_configfile "${1}"
	
	_basename="$1"
	if [[ ! -z "$2" ]]; then
		_basename="$2"
	fi

	if [[ -f "$bidir/$_basename" ]]; then
		echo "Error: there is a base image with \"$_basename\" name !!"
		exit 1
	fi

	# Number of virtual disks
	no_vdisk="${#disk[@]}"
	# Number of processed virtual disks
	np_vdisk="0"

	# Find first disk(primary) in complex of disks and cdroms
	for(( i=0; $np_vdisk < $no_vdisk; ++i)); do
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_vdisk=$(( ++np_vdisk ))

		if [[ ${media[i]} = "disk" &&  ! -z ${disk[i]} ]];  then
			# Check if path is Absolute?
			disk=${disk[i]}
			if [[ $(expr ${disk} : '/') -eq 0 ]]; then
				disk="${vmdir}/${1}/${disk}"
			fi

			echo "Use \"$disk\" disk as base ..."
			# Check if the primary block device exists in the host.
			if [ ! -e ${disk} ]; then
				echo "Error:  Primary virtual drive (${disk}) doesn't exist or isn't readable."
				exit 1
			fi

			$cp -v "${disk}" "$bidir/$_basename"
			exit $?
		fi
	done
	echo "Error:  Primary virtual drive doesn't exist."
	exit 1
}

do_rmbase()
{
	if [[ -z "$1" ]]; then
		echo "usage: rmbase base_name"
		exit 1
	fi

	if [[ ! -f "$bidir/$1" ]]; then
		echo "Error: There isn't any base with \"$1\" name !!"
		exit 1
	fi

	echo "NOTE: after deleting this base, you can't boot all of"
	echo "      your machines that are based on this image !!"
	echo -n "Delete \"$1\", Are you sure (y/*)? "
	read yesno

	case $yesno in
		[yY]*)
			echo -n "Again ... , Are you sure (y/*)? "
			read yesno
			case $yesno in
				[yY]*)
					$rm -v "$bidir/$1"
					exit $?
					;;
				*)
					exit 0
					;;
			esac
			;;
		*)
			exit 0
			;;
	esac

}

# Create A Virtual Machine from a template (base image)
do_create()
{
	if [[ -z ${1} || -z ${2} || -z ${3} ]]; then
		echo "usage: create vm_template host_name host_ID"
		exit 1
	fi

	if [[ -f "${confdir}/${2}.pvm" ]]; then 
		echo "Error: Your host exists right now ..."
		exit 1
	fi

	if [ -r ${bidir}/${1} ]; then
		# Check if is there any template configuration file
		if [[ -f "${bidir}/${1}.pvm" ]]; then
			$sed -e "s/${1}/${2}/g" \
				-e "s/^id=\".*\"/id=\"${3}\"/" \
							"${bidir}/${1}.pvm" > "/tmp/$2-beta"
		else
			$sed -e "s/^disktype\[0\]=\".*\"/disktype\[0\]=\"virtio\"/" \
				-e "s/^media\[0\]=\".*\"/media\[0\]=\"disk\"/" \
				-e "s/^disk\[0\]=\".*\"/disk\[0\]=\"${2}-OS.qcow2\"/" \
				-e "s/^id=\".*\"/id=\"${3}\"/" \
								$template > "/tmp/$2-beta"
		fi
		template="/tmp/${2}-beta"

		do_edit "${2}"
		$rm "/tmp/${2}-beta"

		${kvmimg} create -b  "${bidir}/${1}" -f  qcow2   "${vmdir}/${2}/${2}-OS.qcow2"
	else 
		echo "Error: Can't read base image"
		exit 1
	fi
}

#  ReBuild host configuration file
#  usage: rebuild_conf host "list of parameters seprated with space"
#+      example: rebuild_conf tvm id=\"2\"
#  Note: in each rebuild, disk and eths array rebuiled from scrach.
#+		thus, you should redefine disk and vlans(in parameter list) 
#+           in each call.
rebuild_conf()
{
	temp_conf="/tmp/rconf_$RANDOM"
	clist=( $@ )
	clist_no=${#clist[@]}

	echo > $temp_conf
	for ((i=1; i<$clist_no; ++i)); do
		echo ${clist[i]} >> "$temp_conf"
	done

	# load configs
	load_configfile ${clist[0]}

	# unset arrays
	unset disk
	unset vlan
	. $temp_conf

	# set defaults
	if [[ -z $sid ]]; then
		sid=1
	fi

	# save new config
	echo "#!/bin/bash" > "$confdir/${clist[0]}.pvm"
	echo "id=\"$id\"" >> "$confdir/${clist[0]}.pvm"
	echo "sid=\"$sid\"" >> "$confdir/${clist[0]}.pvm"
	echo "mem=\"$mem\"" >> "$confdir/${clist[0]}.pvm"
	echo "noacpi=\"$noacpi\"" >> "$confdir/${clist[0]}.pvm"
	echo "cpus=\"$cpus\"" >> "$confdir/${clist[0]}.pvm"
	echo "mouse=\"$mouse\"" >> "$confdir/${clist[0]}.pvm"
	echo "nic=\"$nic\"" >> "$confdir/${clist[0]}.pvm"
	echo "boot=\"$boot\"" >> "$confdir/${clist[0]}.pvm"
	echo "host_usb1=\"$host_usb1\"" >> "$confdir/${clist[0]}.pvm"
	
	no_vdisk=${#disk[@]}
	np_vdisk=0
	for ((i=0; $np_vdisk < $no_vdisk; ++i)); do
		# Jump from NULL elements
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		np_vdisk=$(( ++np_vdisk ))

		echo "disktype[$i]=\"${disktype[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "media[$i]=\"${media[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "disk[$i]=\"${disk[i]}\"" >> "$confdir/${clist[0]}.pvm"
	done

	no_eths=${#vlan[@]}
	np_eths=0
	for ((i=0; $np_eths < $no_eths; ++i)); do
		if [[ ${vlan[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_eths=$(( ++np_eths ))

		echo "vlan[$i]=\"${vlan[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "macaddr[$i]=\"${macaddr[i]}\"" >> "$confdir/${clist[0]}.pvm"
	done

	verify_eths "${clist[0]}"
	$rm -f "$temp_conf"
}

do_chconf()
{
	if [[ -z $1 || -z $2 ]]; then
		echo "usage: chconf host parameters-list"
		exit 1
	fi

	ch_args=( $@ )
	# remove command (chconf)
	unset ch_args[0]

	rb_args=( ${ch_args[@]} )
	rebuild_conf ${rb_args[@]}

	# test existance of "VM" directory
	# if doesn't, create him.
	load_configfile "${clist[0]}"
	if [[ ! -d "$vmdir/${clist[0]}" ]]; then
		$mkdir "$vmdir/${clist[0]}"
	fi
}

# Main script
case "${1}" in
	"start")
		check_uid
		do_start "${2}"
		;;
	"startvnc")
		check_uid
		do_start "${2}"
		do_vnc "${2}"
		;;
	"stop")
		check_uid
		do_stop "${2}"
		;;
	"restart")
		check_uid
		do_stop "${2}"
		${sleep} ${sleeptime}
		do_start "${2}"
		;;
	"status")
		do_status "${2}"
		;;
	"vnc")
		do_vnc "${2}"
		;;
	"whichvnc")
		do_whichvnc "${2}"
		;;
	"killvnc")
		do_killvnc "${2}"
		;;
	"create")
		do_create "${2}" "${3}" "${4}"
		;;
	"shutdown")
		do_shutdown "${2}"
		;;
	"reset")
		do_reset "${2}"
		;;
	"mkimg")
		do_mkimg "${2}" "$3" "$4"
		;;
	"mkbimg")
		do_mkbimg "${2}" "$3" "$4"
		;;
	"snaps")
		do_snaps "${2}"
		;;
	"mksnap")
		do_mksnap "${2}" "${3}"
		;;
	"ldsnap")
		do_ldsnap "${2}" "${3}"
		;;
	"rmsnap")
		do_rmsnap "${2}" "${3}"
		;;
	"ls")
		do_ls_ids
		#if [[ -z ${2} ]]; then
		#	do_ls
		#else
		#	if [[ ${2} = "with-ids" ]]; then
		#		do_ls_ids
		#	fi
		#fi 
		;;
	"lst")
		do_lst
		;;
	"mkbase")
		do_mkbase "$2" "$3"
		;;
	"rmbase")
		do_rmbase "$2" 
		;;
	"lscd")
		do_lscd
		;;
	"mkiso")
		do_mkiso "${2}"
		;;
	"rmiso")
		do_rmiso "${2}"
		;;
	"rmvm")
		do_rmvm ${2}
		;;
	"rename")
		do_rename ${2} ${3}
		;;
	"clone")
		do_clone ${2} ${3} ${4}
		;;
	"info")
		do_info ${2}
		;;
	"mon")
		do_mon "${2}"
		;;
	"edit")
		do_edit "${2}"
		;;
	"chconf")
		do_chconf $@
		;;
	"help")
		do_usage
		;;
	*)
		do_usage
		;;
esac

exit 0
