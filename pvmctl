#!/bin/sh
#
# PVM Manager Script

. /etc/pvm.conf
. "$funcdir/vm"
. "$funcdir/offback"

# The file to use as a template when creating new VM configs
template="$basedir/Scripts/template.pvm"

# Default ifup script
defifup="$basedir/Scripts/pvm-ifup"

# Vlan ifups Prefix
vlanifup="$basedir/Scripts/ifup-vlan"
downifup="$basedir/Scripts/ifup-down"

# How long to sleep at certain points in the script
sleeptime="3"

# What are we called?
scriptname=$( "$basename" "$0" )
scriptversion="2.12.0"

# Functions used in the script
load_defaults()
{
	# Which mouse device to use
	# Values:  mouse, tablet
	defmouse="tablet"

	# The network chipset to use in the VM.
	# Values:  rtl1389, e1000, virtio
	defnic="virtio"

	# Which virtual block device to boot from
	# Values:  a=floppy0, b=floppy1, c=disk0, d=disk1/disk2
	defboot="c"

	# Values  for disktype: ide, scsi, virtio
	defdisktype="ide"

	# Values  for media: disk, cdrom
	defmedia="disk"

	# Values for acpi:  no, "blank"
	# no disables ACPI support in the VM
	defacpi=""

	defcache="none"

	mincpus=1
	# Maximum number of cpus per virtual machine
	maxcpus="16"
	# number of host cpus ...
	_hostcpu_no=$($cat /proc/cpuinfo | $grep processor | $wc -l)
	if [[ "$maxcpus" -gt "$_hostcpu_no" ]]; then
		# if host cpus is less than maxcpus, use him as maxcpus
		maxcpus="$_hostcpu_no"
	fi

	#  Adjust these as needed.  These are the min and max amount
	#+ of RAM to assign to a VM, in MB
	minmem="128"
	maxmem="16384"
	# Host memory in kiloobyte ...
	_hostmem=$($cat /proc/meminfo | $grep MemTotal | $awk '{print $2}')
	if [[ $((maxmem * 1024)) -ge $_hostmem ]]; then
		maxmem=$(((_hostmem / 1024 / 1024) * 1024))
	fi
}

do_start()
{
	# Check if a virtual host was given on the commandline
	# Will exit if none was given
	check_host "${1}"

	# Load the default values for all the config options
	load_defaults "${1}"

	# Try to load the config file for the named host
	# Will exit if the config file doesn't exist
	load_configfile "${1}"

	# Check status of the host
	${0} status ${1} > /dev/null
	if [[ $? -eq "0" ]]; then
		# If he is running, all is ok, just exit with 0.
		echo_result "Host is running right now ..."
		exit 0
	fi

	# Check that an ID is set
	if [ -z ${id} ]; then
		echo_error "ID number for this host has not been set."
		exit 1
	fi

	# Set host name to config file name
	host="${1}"

	#  This variables defines the index of the first disk in each category.
	#  We use index 2 for first cdrom, to achive better performance.
	cd_index="2" #cdrom
	ide_index="0"
	scsi_index="0"
	virtio_index="0"
	
	# Number of virtual drives
	no_vdisk="${#disk[@]}"
	# Number of processed virtula drives
	np_vdisk=0
	
	for (( i = 0; "$np_vdisk" < "$no_vdisk"; ++i)); do
		# Jump from NULL elements
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		np_vdisk=$(( ++np_vdisk ))

		# Check if is there any disk string
		disk="${disk[i]}"
		if [[ -z "$disk" ]]; then 
			continue
		fi

		# Check what kind of media to use for the virtual drive
		case "${media[i]}" in
			disk)
				media="disk"
				case "${cache[i]}" in
					"none")
						cachestr=",cache=none"	
						;;
					"writeback")
						cachestr=",cache=writeback"
						;;
					"unsafe")
						cachestr=",cache=unsafe"
						;;
					"writethrough")
						cachestr=",cache=writethrough"
						;;
					*)
						cachestr=",cache=$defcache"
						;;
				esac
				;;
			cdrom)
				media="cdrom"
				;;
			*)
				echo_error "Bad media type for disk($i)."
				exit 1
				;;
		esac

		#  Check if disk path is Absolute? if not, 
		#+ prepend defined pathes to disk.
		if [[ $(expr "${disk}" : '/') -eq 0 ]]; then
			case "$media" in
			disk) 
				disk="${vmstrg}/${disk}" 
				if [[ "$strgtype" = "$STRG_FS" ]]; then
					if [[ ! -z ${rebase[i]} && ${rebase[i]} != "0" ]]; then
						disk="$disk-s${rebase[i]}"
					fi
				fi
				;;
			cdrom) disk="${isodir}/${disk}" ;;
			esac
		fi

		#  Check existance of the disk..
		if [[ ! -e "$disk" ]]; then
			echo_error "disk($i) doesn't exist or isn't readable ($disk)."
			exit 1
		fi

		extboot=""
		# Determine type of the disk
		case "${disktype[i]}" in
			ide)
				disktype="ide"

				# define index of ide disk in complex of disks and cdroms
				case "$media" in
				disk) index="$ide_index" 
					ide_index=$(( ++ide_index ))
					# NOTE: index 2 is reserved for cdroms
					if (( $ide_index == "2" )); then
						if (( $cd_index != 2 )); then
							ide_index=$cd_index
						else
							ide_index=$(( ++ide_index ))
						fi
					fi
					;;
				cdrom)
					if (( $cd_index != 2 && $ide_index >= $cd_index )); then
						index="$ide_index"
						ide_index=$(( ++ide_index ))
					else
						index="$cd_index"
						cd_index=$(( ++cd_index ))
					fi
					;;
				esac
				;;
			virtio)
				disktype="virtio"
				index="$virtio_index"
				if [[ $index = "0" && $ide_index = 0 ]]; then
					extboot=",boot=on"
				fi

				virtio_index=$(( ++virito_index ))
				;;
			scsi)
				disktype="scsi"
				index="$scsi_index"
				if [[ $index = "0" && $ide_index = "0" && $virtio_index = "0" ]]; then
					extboot=",boot=on"
				fi

				scsi_index=$(( ++scsi_index ))
				;;
			*)
				echo_error "Bad disk type for disk($i)."
				exit 1
				;;
		esac

		case ${snapshot[i]} in
			"on")
				disksnapstr=",snapshot=on"
				;;
			"off")
				disksnapstr=",snapshot=off"
				;;
		esac

		# Build the drive entry that will be passed to kvm
		drives[_drives_index]="-drive"
		_drives_index=$((_drives_index + 1))
		drives[_drives_index]="index=$index,media=$media,if=$disktype,file=$disk$extboot$cachestr$disksnapstr"
		_drives_index=$((_drives_index + 1))
	done

	if [[ ($ide_index -eq 0) && ($virtio_index -eq 0) && ($scsi_index -eq 0) && ($cd_index -eq 2) ]]; then
		echo_error "There isn't any boot device(disk) ..."
		exit 1
	fi

	# Set Monitoring to telnet
	confmonitor="unix:$mondir/${host},server,nowait,nodelay";

	# Check which virtual NIC chipset to use
	case "${nic}" in
		rtl8139)
			confnic="rtl8139"
			;;
		e1000)
			confnic="e1000"
			;;
		virtio)
			confnic="virtio"
			;;
		*)
			confnic=${defnic}
			;;
	esac

	# Make ethernet cards
	# Number of Ethernet Cards
	no_eths="${#vlan[@]}"
	# Number of Processed Ethernet Cards
	np_eths=0
	for (( i =0; $np_eths < $no_eths; ++i)); do
		if [[ ${vlan[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_eths=$(( ++np_eths ))

		eth_script=""
		eth_script_cmd=""
		if [[ ! -z "${vlan[i]}" ]]; then
			if [[ $(expr "${vlan[i]}" : '/') -eq 0 ]]; then
				$brctl showmacs "${vlan[i]}" >/dev/null 2>&1
				if [[ "$?" -ne "0" ]]; then
					echo_error "bad virtual switch ${vlan[i]} !"
					exit 1
				fi
				__vsw="${vlan[i]}"
				__if="$__vsw--vm$id$i"
				$tunctl -t "$__if" >/dev/null 2>&1
				tap_mac_addr=$(echo $($ifconfig -a $__if | grep HWaddr) | $cut -d " " -f 5)
				tap_mac_addr="FE:${tap_mac_addr#*:}"
				$ip_cmd link set "$__if" address "$tap_mac_addr"
				$ifconfig "$__if" 0.0.0.0 up
				# bridge vlan[i] exists, just add new interface to it
				$brctl addif "$__vsw" "$__if" >/dev/null 2>&1
				eth_script_cmd="script=no,downscript=$downifup"
			else
				# vlan[i] contains full path to the eth. script
				eth_script="${vlan[i]}"
				if [[ ! -x "$eth_script" ]]; then
					echo_error "ethernet script \"$eth_script\" is not executable"
					exit 1
				fi
				eth_script_cmd="script=$eth_script"
			fi
		fi

		# Setting specific device type for this vlan
		case "${vlantype[i]}" in
			rtl8139)
				confnic="rtl8139"
				;;
			e1000)
				confnic="e1000"
				;;
			virtio)
				confnic="virtio"
				;;
			*)
				confnic=${defnic}
				;;
		esac
		confnet=" $confnet -net nic,macaddr=${macaddr[i]},vlan=$i,model=${confnic} \
				-net tap,vlan=$i,ifname=$__if,$eth_script_cmd"
		unset __if
		unset __vsw
	done

	# Check which virtual mouse chipset to use
	case "${mouse}" in
		mouse)
			confmouse="mouse"
			;;
		tablet)
			confmouse="tablet"
			;;
		*)
			confmouse=${defmouse}
			;;
	esac

	# Check whether to disable ACPI
	case "${acpi}" in
		no)
			confacpi="-no-acpi"
			;;
		*)
			confacpi="$defacpi"
			;;
	esac

	confcpus="$cpus"
	if [[ "$cpus" -lt "$mincpus" ]]; then
		confcpus="$mincpus"
	else if [[ "$cpus" -gt "$maxcpus" ]]; then
		echo_warning "Number of cpus is greater than $maxcpus. Setting cpus to $maxcpus."
		confcpus="$maxcpus"
	     fi
	fi
	if [[ -z $cpus ]]; then
		if [[ -z $cpus_sockets || -z $cpus_cores || -z $cpus_threads ]]; then
			echo_error "Can't calculate number of cpus !"
			exit 1
		fi
		if [[ $(( cpus_sockets * cpus_cores * cpus_threads)) -gt $maxcpus ]]; then
			echo_error "Number of cpus is more than number of host-cpus !"
			exit 1
		fi
		confcpus="sockets=$cpus_sockets,cores=$cpus_cores,threads=$cpus_threads"
	fi
		
	confmem="$mem"
	# Check amount of RAM to be assigned to the VM
	if [[ $mem -lt $minmem ]]; then
		confmem=$minmem
	else if [[ $mem -gt $maxmem ]]; then
		echo_warning "Virtual RAM is greater then $maxmem.  Setting virtual RAM to $maxmem."
		confmem="$maxmem"
	     fi
	fi

	# Check for host-usb device
	if [[ ! -z $host_usb1 ]]; then
		confusb="-usbdevice host:$host_usb1"
	fi
	# number of host usbs
	no_usbs=${#host_usb[@]}
	# number of processes host usbs
	np_usbs=0
	for (( i =0; $np_usbs < $no_usbs; ++i)); do
		if [[ ${host_usb[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_usbs=$(( ++np_usbs ))

		confusb+=" -usbdevice host:${host_usb[i]}"
	done

	# Setting Spice port
	spiceport=$(( id + spicebport ))
	if [[ -z $password ]]; then
		sppasswd="disable-ticketing"
	else
		sppasswd="password=$password"
		vncpasswd=",password"
	fi

	# Start the VM
	echo "Attempting to start VM for ${1} ..."
	${kvm} \
		-name $host \
		-smp $confcpus \
		-m $confmem \
		-vnc "$( $uname -n ):$id"$vncpasswd \
		-spice addr=$( $uname -n ),port=$spiceport,$sppasswd \
		-daemonize \
		-localtime \
		-usb \
		-usbdevice $confmouse \
		$confnet \
		-pidfile "$piddir/$host.pid" \
		-boot menu=on,order=$boot \
		-monitor $confmonitor \
		$confusb \
		$confacpi \
		"${drives[@]}"
	# check if the vm is running?
	if [[ $? -eq 1 ]]; then
		echo_error "some error in starting $host"
		exit 1
	fi
	# set vnc password 
	echo "change vnc password $password" | $socat - UNIX-CONNECT:$mondir/$host > /dev/null

        # Reset the permissions on the PID file
	if [ -e ${piddir}/${host}.pid ]; then
		${chmod} 644 ${piddir}/${host}.pid
	fi

	echo "VM for $1 started."
	# Show the VNC port assigned to the VM.
	echo "VNC port for $1 is: $id"
	echo "Spice port for $1 is: $spiceport"
}

do_stop()
{
	check_host "${1}"

	${0} status ${1} > /dev/null
	if [[ $? -eq "1" ]]; then
		exit 0
	fi

	echo_info "Attempting to stop VM for ${1} ..."
	if [ -r ${piddir}/${1}.pid ]; then
		${kill} -TERM $( ${cat} ${piddir}/${1}.pid )
		${sleep} ${sleeptime}

		if [ -d /proc/$( ${cat} ${piddir}/${1}.pid ) ]; then
			echo_warning "Something is wrong ... couldn't stop the VM."
			echo_warning "         Try to kill him."
			${pkill} -KILL -f -- "-name ${1}"
			${sleep} ${sleeptime}
		fi

		${rm} ${piddir}/${1}.pid >/dev/null 2>&1
	else
		echo_warning "PID file missing or not readable. Try to kill him."
		${pkill} -KILL -f -- "-name ${1}"
		${sleep} ${sleeptime}
	fi

	echo_result "VM for ${1} has stopped."
}

do_pause()
{
	if [[ -z "$1" ]]; then
		echo_usage "pause host";
		exit 1;
	fi
	check_host "$1"
	$pvmctl "status" "$1" > /dev/null
	if [[ $? -ne 0 ]]; then
		echo_error "$1 is off !"
		exit 1
	fi

	do_exec_vm_mon_cmd "$1" "stop" >/dev/null 2>&1
	exit $?
}

do_resume()
{
	if [[ -z "$1" ]]; then
		echo_usage "resume host";
		exit 1;
	fi
	check_host "$1"
	$pvmctl "status" "$1" > /dev/null
	if [[ $? -ne 0 ]]; then
		echo_error "$1 is off !"
		exit 1
	fi

	do_exec_vm_mon_cmd "$1" "c" >/dev/null 2>&1
	exit $?
}

do_vmstatus()
{
	if [[ -z "$1" ]]; then
		echo_usage "vmstatus host";
		exit 1;
	fi
	check_host "$1"
	$pvmctl "status" "$1" > /dev/null
	if [[ $? -ne 0 ]]; then
		echo_result "off"
		exit 0
	fi

	echo_result $(do_exec_vm_mon_cmd "$1" "info status" | $sed -e "1,2d" -e '$d' | $cut -d ' ' -f 3)
}

do_shutdown()
{
	if [[ -z ${1} ]]; then
		echo_usage "shutdown host";
		exit 1;
	fi
	check_host ${1}
	HOST=$1

	#echo "system_powerdown" | $socat - UNIX-CONNECT:$mondir/$HOST > /dev/null
	do_exec_vm_mon_cmd "$1" "system_powerdown" > /dev/null
	echo_result "Shutdown signal sent to ${1} ... "
}

do_reset()
{
	if [[ -z ${1} ]]; then
		echo_usage "reset host";
		exit 1;
	fi
	check_host ${1}
	HOST=$1

	#echo "system_reset" | $socat - UNIX-CONNECT:$mondir/$HOST > /dev/null
	do_exec_vm_mon_cmd "$1" "system_reset" > /dev/null
	echo_result "reset signal sent to ${1} ... "
}

do_status()
{
	if [ -z ${1} ]; then
		# Called with blank argument, show just the names of the running VMs
		echo_result "The following VMs are running:"
		${pgrep} -lf qemu-kvm | ${grep} -v ${scriptname} | ${awk} '{ print $4 }'
	elif [ ${1} = "kvm" ]; then
		# Called with "kvm" argument, show full details of all kvm processes
		echo_result "The following VMs are running:"
		${pgrep} -lf qemu | ${grep} -v ${scriptname}
	elif [ -e ${confdir}/${1}.pvm ]; then
		# Called with a VM host name, show details for just that kvm process
		${pgrep} -lf -- "-name ${1} " | ${grep} -v ${scriptname} > /dev/null
		if [ $? -eq 1 ]; then
			echo_result "VM for ${1} is not running"
			exit 1
		else
			echo_result "VM for ${1} is running"
			exit 0
		fi
	else
		echo_error  "Doesn't understand the command."
		echo ""
		do_usage
		exit 1
	fi
}

# check if the specified host is off.
check_off()
{
	${0} status ${1} > /dev/null
	if [[ $? -eq "0" ]]; then
		echo_result "your host($1) is running ..."
		echo_result "shutdown the host before any work ..."
		exit 1
	fi
}

# Make a backup from lvm configuration
_backup_lvmconf()
{
	local i
	local log_dir

	log_dir="$lvmbackdir/lvm"
	$rm -f "$log_dir.$(( $lvmro - 1 ))"
	for((i=$(($lvmro - 2 )); i>=0; i-- )); do
		if [[ -d "$log_dir.$i" ]]; then
			$mv "$log_dir.$i" "$log_dir.$(($i + 1))"
		fi
	done
	$cp -r "$lvmconf" "$lvmbackdir"
	$mv  "$log_dir" "$log_dir.0"
}

# check if the host has a disk with applied name.
# usage: _is_disk_owner host disk_name
_is_disk_owner()
{
	if [[ -z "$1" || -z "$2" ]]; then
		echo_usage "_is_disk_owner host disk_name"
		exit 1
	fi
	no_vdisk=${#disk[@]}
	for ((i=0; i < $no_vdisk; ++i)); do
		if [[ "${disk[i]}" = "$2" ]]; then
			_disk_rebase_no=${rebase[i]}
			return 0;
		fi
	done
	echo_error "\"$1\" isn't owner of \"$2\" !"
	exit 1
}

do_mkimg()
{
	if [[ -z "$1" || -z "$2" || -z "$3" ]]; then
		echo_usage "mkimg host image_name image_size(M|G)";
		exit 1;
	fi
	check_host ${1}
	load_configfile "${1}"

	if [[ -e "$vmstrg/$2" ]]; then
		echo_error "Image \"$2\" exists right now !"
		exit 1;
	fi
	case $strgtype in
		$STRG_FS)
			if [ ! -d "$vmstrg" ]; then
				$mkdir -p "$vmstrg"
				if [[ $? -ne 0 ]]; then
					echo_error "Can't create \"$vmstrg\" directory !"
					exit 1
				fi
			fi
			$kvmimg create -f qcow2 -o preallocation=metadata "$vmstrg/${2}" "${3}" > /dev/null
			;;
		$STRG_VG)
			$lvcreate -A y -n "$2" -L "$3" "$vmstrg" > /dev/null
			if [[ $? -eq 0 ]]; then
				_backup_lvmconf
			fi
			;;
	esac
	if [[ $? -eq 0 ]]; then
		echo_result "Image \"$2\" created. "
	else
		echo_error "Can't create new disk, $( pperror $? )"
		exit 1
	fi
}

do_convertimg()
{
	if [[ -z "$1" || -z "$2" || -z "$3" ]]; then
		echo_usage "mkimg host image_name new_name";
		exit 1;
	fi
	check_host ${1}
	load_configfile "${1}"

	if [[ -e "$vmstrg/$3" ]]; then
		echo_error "Image \"$2\" exists right now !"
		exit 1;
	fi
	case $strgtype in
		$STRG_FS)
			if [ ! -d "$vmstrg" ]; then
				$mkdir -p "$vmstrg"
				if [[ $? -ne 0 ]]; then
					echo_error "Can't create \"$vmstrg\" directory !"
					exit 1
				fi
			fi
			$kvmimg convert -O qcow2 "$vmstrg/${2}" "$vmstrg/${3}" > /dev/null
			;;
		$STRG_VG)
			echo_error "convert don't support LVM !"
			;;
	esac
	if [[ $? -eq 0 ]]; then
		echo_result "Image \"$3\" created. "
	else
		echo_error "Can't create new disk: $( pperror $? )"
		exit 1
	fi
}

_do_rmimg()
{
	if [[ -z "$1" || -z "$2" ]]; then
		echo_usage "rmimg host image_name";
		exit 1;
	fi

	if [[ -e "$vmstrg/$2" ]]; then
		case $strgtype in
			$STRG_FS)
				# "*" to remove all of rebases.
				$rm -f "$vmstrg/$2" > /dev/null
				;;
			$STRG_VG)
				$lvremove -A y -f "$vmstrg/$2" > /dev/null
				if [[ $? -eq 0 ]]; then
					_backup_lvmconf
				fi
				;;
		esac
	fi
	if [[ $? -eq 0 ]]; then
		echo_info "Image \"$2\" removed. "
	else
		echo_error "Can't remove \"$2\": $( $perror $? )"
		exit 1
	fi
}

do_rmimg()
{
	if [[ -z ${1} || -z ${2} ]]; then
		echo_usage "rmimg host image_name";
		exit 1;
	fi
	check_host "$1"
	check_off "$1"
	load_configfile "${1}"
	_is_disk_owner "$1" "$2"
	#echo -n "removing image \"$2\": Are you sure (y/*)? "
	#read yesno
	#if [[ "$yesno" != "y" ]]; then
	#	exit 0;
	#fi
	are_you_sure "removing image \"$2\":"
	if [[ $? -eq "0" ]]; then
		exit 1;
	fi
	_do_rmimg "$1" "$2"
}

# rename the image
do_rnimg()
{
	if [[ -z "$1" || -z "$2" || -z "$3" ]]; then
		echo_usage "rnimg host image_name new_name";
		exit 1;
	fi
	check_host "$1"
	check_off "$1"
	load_configfile "$1"
	
	_is_disk_owner "$1" "$2"
	if [[ ("$strgtype" = "$STRG_FS") && ("$_disk_rebase_no" -gt "0") ]]; then
		echo_error "Disk is in rebasing state, you should rebuild him first .."
		exit 1
	fi
	if [[ ! -e "$vmstrg/$2" ]]; then
		echo_error "Image \"$2\" doesn't exist !"
		exit 1
	fi
	if [[ -e "$vmstrg/$3" ]]; then
		echo_error "New image \"$3\" exists right now !"
		exit 1
	fi
	#echo -n "renaming image \"$2\": Are you sure (y/*)? "
	#read yesno
	#if [[ "$yesno" != "y" ]]; then
	#	exit 0;
	#fi
	are_you_sure "renaming image \"$2\" to \"$3\":"
	if [[ $? -eq "0" ]]; then
		exit 1;
	fi

	case $strgtype in
		$STRG_FS)
			$mv "$vmstrg/$2" "$vmstrg/$3" > /dev/null
			;;
		$STRG_VG)
			$lvrename -A y "$vmstrg/$2" "$3" > /dev/null
			if [[ $? -eq 0 ]]; then
				_backup_lvmconf
			fi
			;;
	esac
	if [[ $? -eq 0 ]]; then
		echo_result "Image \"$2\" renamed to \"$3\". "
	else
		echo_error "Can't rename \"$2\": $( $perror $? )"
		exit 1
	fi
}

# clone image
_do_cloneimg()
{
	if [[ -z "$1" || -z "$2" || -z $3 ]]; then
		echo_usage "_do_cloneimg /path/to/image /path/to/clone clone_strgtype"
		exit 1
	fi
	if [[ ! -e "$1" ]]; then
		echo_error "Source image doesn't exist !"
		return 1
	fi
	case $3 in
		$STRG_FS)
			__FMT_STR="-O qcow2"
			;;
		$STRG_VG)
			if [[ ! -e "$2" ]]; then
				echo_error "destination image doen't exist !"
				return 1
			fi
			;;
	esac
	$kvmimg convert $__FMT_STR "$1" "$2" > /dev/null
}

#  This function verifyes Ethernet Cards for any change in them and 
#+ Generate new MACaddresses if required.
#  Usage: review_eths host
verify_eths()
{
	# unset before loaded arrays
	unset vlan
	unset macaddr

	load_configfile "$1"

	# Number Of ethernet cards
	no_eths=${#vlan[@]}
	# Number Of Processed ethernet cards
	np_eths=0

	_any_change=0
	for ((_i=0; $np_eths < $no_eths; ++_i)); do
		if [[ ${vlan[_i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_eths=$(( ++np_eths ))

		if [[ -z ${macaddr[_i]} ]]; then
			macaddr[_i]=$($macgen)
			_any_change="1"
		fi
	done

	if [[ $_any_change -eq "0" ]]; then
		# there is no change in ethernet cards, so exit happy
		return 0
	fi
	# Modify Config File
	_tmp_conf="/tmp/__pvmctl_$RANDOM"
	$sed -i -e "/macaddr\[.*\]=\".*\"/d" "${confdir}/${1}.pvm" 
	# Number of MAC Addresses
	no_macs=${#macaddr[@]}
	# Number of Processed MAC Addresses
	np_macs="0"
	for ((_i=0; $np_macs < $no_macs; ++_i)); do
		if [[ ${macaddr[_i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		np_macs=$(( ++np_macs ))

		if [[ ! -z ${macaddr[_i]} ]]; then
			echo "macaddr[$_i]=\"${macaddr[_i]}\"" >>  "${confdir}/${1}.pvm" 
		fi
	done
	return 0
}

# Verify off-site 
verify_offback_sched()
{
	local days
	local hour
	local minute
	local cpos

	load_configfile "$1"

	(
		flock -s 201
		$sed -i -e "/ $1$/d" $rcf_offback_sched >/dev/null 2>&1
		if [[ ! -z $offback_weekday ]]; then
			days=$offback_weekday
			if [[ $days = "all" ]]; then days="*"; fi
			if [[ ! -z $offback_hour ]]; then
				cpos=$(expr index $offback_hour ':')
				if [[ $cpos -ne "0" ]]; then
					hour=${offback_hour:0:$((cpos - 1))}
					minute=${offback_hour:$cpos}

					echo "$minute $hour * * $days root $pvm_offsite_backup $1" >> $rcf_offback_sched 
				fi
			fi
		fi
	) 201>$lck_offback_sched
}

#  ReBuild host configuration file
#  usage: _rebuild_conf host "list of parameters seprated with space"
#+      example: _rebuild_conf tvm id=\"2\"
_rebuild_conf()
{
	temp_conf="/tmp/rconf_$RANDOM"
	clist=(${@})
	clist_no=${#clist[@]}

	echo > $temp_conf
	for __var in "$@"; do
		echo ${__var//' '/'\ '} >> "$temp_conf"
	done

	. $temp_conf

	# set defaults
	if [[ -z $sid ]]; then
		sid=0
	fi

	# save new config
	echo "#!/bin/bash" > "$confdir/${clist[0]}.pvm"
	echo "id=\"$id\"" >> "$confdir/${clist[0]}.pvm"
	echo "sid=\"$sid\"" >> "$confdir/${clist[0]}.pvm"
	echo "ip=\"$ip\"" >> "$confdir/${clist[0]}.pvm"
	echo "des=\"$des\"" >> "$confdir/${clist[0]}.pvm"
	echo "offback_weekday=\"$offback_weekday\"" >> "$confdir/${clist[0]}.pvm"
	echo "offback_hour=\"$offback_hour\"" >> "$confdir/${clist[0]}.pvm"
	echo "offback_autosnap_no=\"$offback_autosnap_no\"" >> "$confdir/${clist[0]}.pvm"
	echo "mem=\"$mem\"" >> "$confdir/${clist[0]}.pvm"
	echo "noacpi=\"$noacpi\"" >> "$confdir/${clist[0]}.pvm"
	echo "cpus=\"$cpus\"" >> "$confdir/${clist[0]}.pvm"
	echo "cpus_sockets=\"$cpus_sockets\"" >> "$confdir/${clist[0]}.pvm"
	echo "cpus_cores=\"$cpus_cores\"" >> "$confdir/${clist[0]}.pvm"
	echo "cpus_threads=\"$cpus_threads\"" >> "$confdir/${clist[0]}.pvm"
	echo "mouse=\"$mouse\"" >> "$confdir/${clist[0]}.pvm"
	echo "nic=\"$nic\"" >> "$confdir/${clist[0]}.pvm"
	echo "boot=\"$boot\"" >> "$confdir/${clist[0]}.pvm"
	echo "host_usb1=\"$host_usb1\"" >> "$confdir/${clist[0]}.pvm"
	echo "password=\"$password\"" >> "$confdir/${clist[0]}.pvm"
	echo "basevm=\"$basevm\"" >> "$confdir/${clist[0]}.pvm"
	
	no_usbs=${#host_usb[@]}
	np_usbs=0
	for ((i=0; $np_usbs < $no_usbs; ++i)); do
		if [[ ${host_usb[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_usbs=$(( ++np_eths ))

		echo "host_usb[$i]=\"${host_usb[i]}\"" >> "$confdir/${clist[0]}.pvm"
	done

	no_vdisk=${#disk[@]}
	np_vdisk=0
	for ((i=0; $np_vdisk < $no_vdisk; ++i)); do
		# Jump from NULL elements
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		np_vdisk=$(( ++np_vdisk ))

		echo "disktype[$i]=\"${disktype[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "media[$i]=\"${media[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "disk[$i]=\"${disk[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "cache[$i]=\"${cache[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "snapshot[$i]=\"${snapshot[i]}\"" >> "$confdir/${clist[0]}.pvm"
	done

	no_eths=${#vlan[@]}
	np_eths=0
	for ((i=0; $np_eths < $no_eths; ++i)); do
		if [[ ${vlan[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_eths=$(( ++np_eths ))

		echo "vlan[$i]=\"${vlan[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "vlantype[$i]=\"${vlantype[i]}\"" >> "$confdir/${clist[0]}.pvm"
		echo "macaddr[$i]=\"${macaddr[i]}\"" >> "$confdir/${clist[0]}.pvm"
	done

	verify_eths "${clist[0]}"
	verify_offback_sched "${clist[0]}"
	$rm -f "$temp_conf"
}

#  Note: in each do_chconf, disk and eths array rebuiled from scrach.
#+		thus, you should redefine disk and vlans(in parameter list) 
#+           in each call.
do_chconf()
{
	if [[ -z $1 ]]; then
		echo_usage "chconf host parameters-list"
		exit 1
	fi

	rb_args=(${@})

	# load configs
	load_configfile "${rb_args[0]}"
	# unset arrays
	unset disk
	unset vlan
	unset host_usb

	_rebuild_conf "$@"
}

# Modifing some host parameters base on user request
_do_modconf()
{
	if [[ -z $1 ]]; then
		echo_usage "chconf host [parameters-list]"
		exit 1
	fi

	rb_args=(${@})
	# load configs
	load_configfile "${rb_args[0]}"

	_rebuild_conf ${rb_args[@]}

}

# returns the biggest ID in virtual machines
do_genid()
{	
	for I in `ls ${confdir}`; do
		_id=$($sed -n -e "/^id=\".*\"/p" "${confdir}/${I}" | cut -d "=" -f 2)
		_id=${_id%\"}
		_id=${_id#\"}
		_out="$_out$_id\n"
	done
	echo_result $(( $(echo -e "$_out" | sort -nr | $sed -n -e "1p") + 1 ))
}

# Create new virtual machine.
# usage: new name-of-new-vm [sid]
do_new()
{
	if [[ -z $1 || -z $2 ]]; then
		echo_usage "new host_name sid"
		exit 1
	fi
	if [[ -e ${confdir}/${1}.pvm ]]; then
		echo_error "Your host exists right now ..."
		exit 1;
	fi
	_verify_vmstrg "$1" "$2"
	if [ -r "$template" ]; then
		if [ -w "$confdir" ]; then
			$cp "$template" "$confdir/$1.pvm"
			#$sed -e "s/^id=\".*\"/id=\"$( do_genid )\"/"  ${template} > "${confdir}/${1}.pvm"
			#if [[ ! -z "$2" ]]; then
				#$sed -i -e "s/^sid=\".*\"/sid=\"$2\"/" "${confdir}/${1}.pvm" 	
			#fi
			_do_modconf "$1" "id=\"$( do_genid )\"" "sid=$2"
			echo_result "New virtual machine ($1) has been created ..."
		else
			echo_error "You don't have write permission for ${confdir}"
			exit 1
		fi
	else
		echo_error "The template config file (${template}) doesn't exist or isn't readable."
		exit 1
	fi
}

# Create A Virtual Machine from a template (base image)
do_create()
{
	if [[ -z "$1" || -z "$2" || -z "$3" ]]; then
		echo_usage "create template_name host_name sid"
		exit 1
	fi

	_verify_vmstrg "$2" "$3"
	# TODO support of VG
	if [[ "$strgtype" = "$STRG_VG" ]]; then
		echo_error "Doesn't support VG storage yet .."
		exit 1;
	fi

	if [[ -f "${confdir}/${2}.pvm" ]]; then 
		echo_error "Your host exists right now ..."
		exit 1
	fi
	if [ -r ${bidir}/${1} ]; then
		# Check if is there any template configuration file
		if [[ -f "${bidir}/${1}.pvm" ]]; then
			$sed -e "s/${1}/${2}/g" "${bidir}/${1}.pvm" > "/tmp/$2-beta"
			template="/tmp/${2}-beta"
		fi
		do_new "$2" "$3"
		if [[ -f "${bidir}/${1}.pvm" ]]; then 
			$rm "/tmp/${2}-beta"
			do_chconf "$2" basevm="$1" disk[0]="$2-OS.qcow2"
		else
			do_chconf "$2" basevm="$1" disktype[0]="ide" media[0]="disk" disk[0]="$2-OS.qcow2"
		fi
		"$mkdir" -p "$vmstrg" 
		"$kvmimg" create -b  "$bidir/$1" -f  qcow2   "$vmstrg/$2-OS.qcow2" > /dev/null 
	else 
		echo_error "Can't read base image"
		exit 1
	fi
}

do_clone()
{
	if [[ -z $1 || -z $2 ]]; then
		echo_usage "clone host clone_name [clone_sid]";
		exit 1;
	fi	
	check_host "$1"
	load_configfile "$1"
	if [[ $(check_off "$1" >/dev/null ) -eq 1 ]]; then
		echo_info "$1 is run ..."
		are_you_sure "Cloning from running machine,"
		if [[ "$?" -eq 0 ]]; then
			echo_result "Cloning canceled ..."
			exit 1
		fi
	fi
	if [[ -e "$confdir/$2.pvm" ]]; then
		echo_error "Clone exists right now !" 
		exit 1
	fi

	old_vmstrg="$vmstrg"
	c_sid=$3
	if [[ -z "$3" ]]; then 
		c_sid=$sid; 
	else
		isvalid_vmstrg "$3"
	fi

	echo_info "Generating config file ..."
	do_new "$2" "$c_sid"

	load_configfile "$2"
	echo_info "Creating disks, please wait ..."
	case $strgtype in
		$STRG_FS)
			$mkdir -p "$vmstrg"
			PREFIX=""
			;;
		$STRG_VG)
			PREFIX="$RANDOM-"
			;;
	esac

	no_vdisk=${#disk[@]}
	np_vdisk=0
	for ((i=0; $np_vdisk < $no_vdisk; ++i)); do
		# Jump from NULL elements
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		np_vdisk=$(( ++np_vdisk ))
		echo_info "Processing Disk #$i; ${disk[i]} ..."
		# if disk path, is a full path, we leave him unchanged
		if [[ $(expr "${disk[i]}" : '/') -eq 0 ]]; then
			if [[ ${media[i]} = "disk" ]]; then
				if [[ $strgtype = $STRG_VG ]]; then
					disk_size=$( $kvmimg info "$old_vmstrg/${disk[i]}" | grep "virtual size: " | cut -d ' ' -f 3 )
					do_mkimg "$2" "$PREFIX${disk[i]}" "$disk_size"
				fi
				_do_cloneimg "$old_vmstrg/${disk[i]}" "$vmstrg/$PREFIX${disk[i]}" "$strgtype"
				disk[i]="$PREFIX${disk[i]}"
			fi
		fi
		__disk_str="$__disk_str disk[$i]=\"${disk[i]}\""
	done

	no_eths=${#vlan[@]}
	np_eths=0
	for ((i=0; $np_eths < $no_eths; ++i)); do
		if [[ ${vlan[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_eths=$(( ++np_eths ))
		__eth_str="$__eth_str vlan[$i]=\"${vlan[i]}\" vlantype[$i]=\"${vlantype[i]}\""
		if [[ -z "$DO_CLONE_FIX_MACS" ]]; then macaddr[i]=""; fi
	done

	do_chconf "$2" $__disk_str $__eth_str
	echo_result "clone(${2}) created ... "
}

do_edit()
{
	if [[ -z $1 ]]; then
		echo_usage "edit host_name"
		exit 1
	fi

	# If the config file exists, and is writable by the user, then load it using $EDITOR
	if [ -e ${confdir}/${1}.pvm ]; then
		if [ -w ${confdir}/${1}.pvm ]; then
			${EDITOR} ${confdir}/${1}.pvm
		else
			echo_error "You don't have write permission for ${confdir}/${1}.pvm"
			exit 1
		fi
	else
		echo_error "VM you want to edit dosen't exist !!!"
		exit 1
	fi
	verify_eths "${1}"
}

do_rename()
{
	if [[ -z ${1} || -z ${2} ]]; then
		echo_usage "rename host new-name";
		exit 1;
	fi	
	check_host ${1}
	check_off ${1}
	load_configfile "${1}"

	if [[ -f "$confdir/${2}.pvm" ]]; then
		echo_error "New Machine Exists right now !!."
		exit 1
	fi

	echo_info "Generating config file ..."
	$mv "$confdir/${1}.pvm" "$confdir/${2}.pvm" 
	if [[ $strgtype = "$STRG_FS" && -d "$vmstrg" ]]; then
		$mv $vmstrg "${vmstrg/%$1/$2}"
	fi

	echo_result "${1} renamed to ${2}"
}

do_rmvm()
{
	if [[ -z ${1} ]]; then
		echo_usage "rmvm host";
		exit 1;
	fi
	check_host ${1}
	check_off ${1}
	load_configfile "${1}"

	#echo -n "remove ${1}: Are you sure (y/*)? "
	#read yesno
	#if [[ $yesno != "y" ]]; then
	#	exit 0
	#fi
	are_you_sure "remove \"$1\":"
	if [[ $? -eq "0" ]]; then
		exit 1
	fi

	no_vdisk=${#disk[@]}
	np_vdisk=0
	for ((i=0; $np_vdisk < $no_vdisk; ++i)); do
		# Jump from NULL elements
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		np_vdisk=$(( ++np_vdisk ))
		# if disk path, is full path, we leave him unchanged
		if [[ $(expr "${disk[i]}" : '/') -eq 0 ]]; then
			if [[ ${media[i]} = "disk" ]]; then
				_do_rmimg "$1" ${disk[i]}
			fi
		fi
	done

	if [[ "$strgtype" = "$STRG_FS" ]]; then
		$rm -fr "$vmstrg" > /dev/null 2>&1
	fi
	$rm -f "$confdir/$1.pvm" > /dev/null 2>&1
}

# Move VM between storages
do_mvvm()
{
	if [[ -z "$1" || -z "$2" ]]; then
		echo_usage "mvvm host new_sid"
		exit 1
	fi
	are_you_sure "Move $1 to storage[$2]:"
	if [[ $? -eq 0 ]]; then
		exit 1
	fi
	check_host "$1"
	check_off "$1"
	load_configfile "$1"

	if [[ $2 = $sid ]]; then
		echo_error "new sid(\"$2\") is equal to current sid !"
		exit 1
	else
		isvalid_vmstrg "$2"
	fi
	__new_name="$RANDOM$1"
	echo_info "Creating clone \"$__new_name\" ..."
	DO_CLONE_FIX_MACS=1 # fixing mac addresses
	do_clone "$1" "$__new_name" "$2"
	unset DO_CLONE_FIX_MACS
	echo_info "Removing old VM ..."
	do_rmvm "$1"
	echo_info "Renaming new VM ..."
	do_rename "$__new_name" "$1"
}

# changing running-host CR-Rom 
# it must be used for running virtual machines.
# it will change or eject specified cdrom at host.
# usage: do_chcdrom host cdrom# [new-iso-file-path]
# cdrom#: may be 1 ro 2
# new-iso-file-path:
#	may be null, in the situation the cdrom would be ejected.
#	may be a fullpath, that would be used as new cd-rom
#	or an iso file name, then would prepend to haim "$isodir"
do_chcdrom()
{
	if [[ -z "$1" || -z "$2" ]]; then
		echo_usage "chcdrom host cdrom# [new-iso-file-path]"
		echo_usage "  you can use \"hostcd1\" and \"hostcd2\" to use"
		echo_usage "  physical server cdroms"

		exit 1
	fi

	check_host "$1"
	load_configfile "$1"
	$pvmctl "status" "$1" > /dev/null
	if [[ $? -ne 0 ]]; then
		echo_error "$1 is off !"
		exit 1
	fi

	case $2 in
	"1") cdid=0
		;;
	"2") cdid=1
		;;
	*) echo_error "bad cdrom index - $2 !"
		exit 1
		;;
	esac

	if [[ -z "$3" ]]; then
		#echo "eject ide1-cd$cdid" | $socat - UNIX-CONNECT:"$mondir/$1" >/dev/null 2>&1
		do_exec_vm_mon_cmd $1 "eject ide1-cd$cdid" >/dev/null 2>&1
	else
		_cpath="$3"
		# if file path isn't a full name, prepend "isodir" path.
		case "$_cpath" in
		"hostcd1") _cpath="/dev/sr0"
			;;
		"hostcd2") _cpath="/dev/sr1"
			;;
		*)
			if [[ $(expr "$_cpath" : '/') -eq 0 ]]; then
				_cpath="$isodir/$_cpath"
			fi
			;;
		esac
		if [[ -e "$_cpath" ]]; then
			#echo "change ide1-cd$cdid $_cpath" | $socat - UNIX-CONNECT:"$mondir/$1" >/dev/null 2>&1
			do_exec_vm_mon_cmd $1 "change ide1-cd$cdid $_cpath" >/dev/null 2>&1
		else
			echo_error "Bad iso/cd file !"
			exit 1
		fi
	fi
}

# Rebasing virtual machine ...
# do_rebase "host" "[disk_number]"
do_rebase()
{
	if [[ -z "$1" ]]; then
		echo_usage "snaps host";
		exit 1;
	fi
	check_host "$1"
	check_off "$1"
	load_configfile "$1"
}

do_snaps()
{
	if [[ -z "$1" ]]; then
		echo_usage "snaps host";
		exit 1;
	fi
	check_host "$1"
	load_configfile "$1"

	if [[ "$strgtype" = "$STRG_VG" ]]; then
		echo_error "Doesn't support VG storage yet .."
		exit 1;
	fi
	HOST=$1
	if [[ ! -e "$mondir/$HOST" ]]; then
		echo_error "There isn't any monitor socket .."
		exit 0
	fi
	$pvmctl "status" $HOST >/dev/null 2>&1
	if [[ $? -ne 0 ]]; then
		echo_error "Host is OFF, for snapshot activities must be ON."
		exit 0
	fi
	#__snaps=$(echo "info snapshots" | $socat - UNIX-CONNECT:$mondir/$HOST)
	__snaps=$(do_exec_vm_mon_cmd $HOST "info snapshots")
	if [[ -z "$__snaps" ]]; then
		echo_error "Host isBUSY !!!"
		exit 1
	fi
	echo_result "${1} snapshots:"
	#echo "info snapshots" | $socat - UNIX-CONNECT:$mondir/$HOST | $sed -e "1,2d" -e "\$d" 
	do_exec_vm_mon_cmd $HOST "info snapshots" | $sed -e "1,2d" -e "\$d"
}

_wait_for_snaps_activities()
{
	for((;;)); do
		echo_info  "."
		$pvmctl "snaps" "$1" >/dev/null 2>&1
		if [[ $? -eq 0 ]]; then
			return 0
		fi
		$sleep 30
	done    
}

do_mksnap()
{
	if [[ -z "$1" ]]; then
		echo_usage "mksnap host [tag|id]";
		exit 1;
	fi
	check_host "$1"
	load_configfile "$1"

	if [[ "$strgtype" = "$STRG_VG" ]]; then
		echo_error "Doesn't support VG storage yet .."
		exit 1;
	fi
	HOST=$1

	echo_info "Make an snapshot for $1"
	echo_info "Please wait ..."
	#echo "savevm $2" |  $socat - UNIX-CONNECT:$mondir/$HOST  > /dev/null 
	do_exec_vm_mon_cmd $1 "savevm $2"  > /dev/null
	_wait_for_snaps_activities "$1"
	echo_result "The Snapshot been created"
}

do_ldsnap()
{
	if [[ -z "$1" || -z "$2" ]]; then
		echo_usage "ldsnap host tag|id";
		exit 1;
	fi
	check_host "$1"
	load_configfile "$1"

	if [[ "$strgtype" = "$STRG_VG" ]]; then
		echo_error "Doesn't support VG storage yet .."
		exit 1;
	fi
	HOST=$1

	echo_info "Load snapshot for $1 with tag|id=$2"
	echo_info "Please wait ..."
	#echo "loadvm $2" | $socat - UNIX-CONNECT:$mondir/$HOST  > /dev/null 
	do_exec_vm_mon_cmd $HOST "loadvm $2" > /dev/null 
	_wait_for_snaps_activities "$1"
	echo_result "The Snapshot been loaded"
}

do_rmsnap()
{
	if [[ -z "$1" || -z "$2" ]]; then
		echo_usage "rmsnap host tag|id";
		exit 1;
	fi
	check_host "$1"
	load_configfile "$1"

	if [[ "$strgtype" = "$STRG_VG" ]]; then
		echo_error "Doesn't support VG storage yet .."
		exit 1;
	fi
	HOST="$1"

	echo_info "delete snapshot from $1 with tag|id=$2"
	echo_info "please wait ..."
	#echo "delvm $2" | $socat - UNIX-CONNECT:$mondir/$HOST > /dev/null 
	do_exec_vm_mon_cmd $HOST "delvm $2" > /dev/null 
	_wait_for_snaps_activities "$1"
	echo_result "The Snapshot been removed"
}

do_mon()
{
	if [[ -z ${1} ]]; then
		echo_usage "mon host";
		exit 1;
	fi
	check_host ${1}	
	HOST=$1

	$socat - UNIX-CONNECT:$mondir/$HOST  
}

do_ls()
{
	echo_result "list of installed hosts:"
	echo_result "------------------------"
	for I in `ls ${confdir}`; do
		echo_result "${I%.pvm}"
	done
}

do_ls_ids()
{
	printf "%-20s%s\n" "host" "id"
	printf "%-20s%s\n" "----" "--"
	for I in `ls ${confdir}`; do
		_out="$_out${I%.pvm} "
		_id=$($sed -n -e "/^id=\".*\"/p" "${confdir}/${I}" | cut -d "=" -f 2)
		_id=${_id%\"}
		_id=${_id#\"}
		_out="$_out$_id\n"
	done
	echo -e "$_out" | awk '\
		{
			sort = "sort -k 2nr" 
			printf "%-20s%d\n", $1, $2|sort 
		}' | $sed -e "$ d"
}

do_lst()
{
	echo_result "list of virtual machine templates:"
	echo_result "----------------------------------"
	$ls ${bidir} | while read I; do
		_conf=$(expr match "$I" ".*.pvm")
		if [[ $_conf -eq 0 ]]; then
			echo_result "$I"
		fi
	done
}

do_lscd()
{
	echo_result "list of CD Images (ISO files):"
	echo_result "------------------------------"
	$ls ${isodir} | while read _i; do
		echo_result "$_i"
	done
}

do_lsid()
{
	printf "%-10s%-10s%-10s%-10s%-30s%s\n" "ID" "Type" "Size" "Free" "Storage Path" "name"
	printf "%-10s%-10s%-10s%-10s%-30s%s\n" "--" "----" "----" "----" "------------" "----"
	read_config_file "$cf_VMStorages" | while read __i; do
		__id=$(echo $__i | $cut -s -d ";" -f 1)
		__type=$(echo $__i | $cut -s -d ";" -f 2)
		__path=$(echo $__i | $cut -s -d ";" -f 3)
		__name=$(echo $__i | $cut -s -d ";" -f 4)
		case "$__type" in
			"$STRG_FS")
				_tx=$(df -h "$__path" 2>/dev/null | $sed -e "1d")
				__size=$(echo $_tx | cut -d " " -f 2)
				__free=$(echo $_tx | cut -d " " -f 4)
				;;
			"$STRG_VG")
				_tx=$(vgs 2>/dev/null | grep $($basename "$__path"))
				__size=$(echo $_tx | cut -d " " -f 6)
				__free=$(echo $_tx | cut -d " " -f 7)
				;;
		esac
		printf "%-10s%-10s%-10s%-10s%-30s%s\n" "$__id" "$__type" "$__size" "$__free" "$__path" "$__name"
	done
}

do_info()
{
	if [[ -z ${1} ]]; then
		echo_usage "info host";
		exit 1;
	fi
	check_host ${1}

	cat $confdir/${1}.pvm | $sed -e "/^#/d" -e "/^$/d" \
		-e "/disktype/i\----------" \
		-e "/has2eth/i\----------"
}

do_binfo()
{
	if [[ -z "$1" ]]; then
		echo_usage "lsdisk host"
		exit 1
	fi
	check_host "$1"
	load_configfile "$1"
	load_defaults

	_out="$_out""item value\n"
	_out="$_out""------------ ------\n"
	_out="$_out""id $id\n"
	_out="$_out""storage_id $sid\n"
	_out="$_out""ip_address $ip\n" 
	_out="$_out""desciption $des\n" 
	_out="$_out""memory $mem\n" 
	_out="$_out""noacpi $noacpi\n" 
	_out="$_out""cpu# $cpus\n" 
	_out="$_out""mouse_type $mouse\n" 
	_out="$_out""network $nic\n" 
	_out="$_out""first_boot $boot\n" 
	_out="$_out""basevm $basevm\n" 
	_out="$_out""host_usb1 $host_usb1\n" 	

	# number of host usbs
	no_usbs=${#host_usb[@]}
	# number of processes host usbs
	np_usbs=0
	for (( i =0; $np_usbs < $no_usbs; ++i)); do
		if [[ ${host_usb[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_usbs=$(( ++np_usbs ))

		_out+="host_usb[$i] ${host_usb[i]}"
	done

	echo -e "$_out" | awk '\
		{
			printf "%-20s%s\n", $1, $2 
		}' 

	echo "Virtual Machine Disks:"
	_out="id media type rebase snap image\n"
	_out="$_out""-- ----- ---- ---- ------ -----\n"
	no_vdisk=${#disk[@]}
	np_vdisk=0
	for ((i=0; $np_vdisk < $no_vdisk; ++i)); do
		# Jump from NULL elements
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue
		fi
		(( ++np_vdisk ))
		_out="$_out""$i ${media[i]} ${disktype[i]} ${rebase[i]} ${snapshot[i]} ${disk[i]}\n"
	done

	echo -e "$_out" | awk '\
		{
			printf "%-10s%-15s%-10s%-10s%-10s%s\n", $1, $2, $3, $4, $5, $6
		}' 

	echo "Virtual Machine Network:"
	_out="id type mac vlan\n"
	_out="$_out""-- ---- --- ----\n"
	no_eths=${#vlan[@]}
	np_eths=0
	for ((i=0; $np_eths < $no_eths; ++i)); do
		if [[ ${vlan[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		(( ++np_eths ))
		if [[ -z "${vlantype[i]}" ]]; then 
			if [[ -z "${nic}" ]]; then 
				vlantype[i]="$defnic"; 
			else
				vlantype[i]="$nic"
			fi
		fi
		_out="$_out""$i ${vlantype[i]} ${macaddr[i]} ${vlan[i]}\n"
	done
	echo -e "$_out" | awk '\
		{
			printf "%-10s%-10s%-22s%s\n", $1, $2, $3, $4
		}' 
}

do_mkiso()
{
	if [[ -z "$1" ]]; then
		echo_usage "mkiso iso_name"
		exit 1
	fi

	_iso="$1"
	if [[ $(expr "$1" : '/') -eq "0" ]]; then
		_iso="$isodir/$1"
	fi

	if [[ -f "$_iso" ]]; then
		#echo -n "Target File exist ... Replace it (y/*)? "
		are_you_sure "Target File exist, Replace it: "
		#read yesno

		#case $yesno in
		#	[yY]*)
		#		;;
		#	*)
		#		exit 0
		#		;;
		#esac
		if [[ $? -eq 0 ]]; then
			exit 1
		fi
	fi

	$dd if="/dev/cdrom" of="$_iso"
	exit $?
}

do_rmiso()
{
	if [[ -z "$1" ]]; then
		echo_usage "rmiso iso_name"
		exit 1
	fi

	_iso="$1"
	if [[ $(expr "$1" : '/') -eq "0" ]]; then
		_iso="$isodir/$1"
	fi

	if [[ -f "$_iso" ]]; then
		#echo -n "Delete \"$1\", Are you sure (y/*)? "
		are_you_sure "Delete \"$1\":"
		#read yesno

		#case $yesno in
		#	[yY]*)
		#		$rm -v "$_iso"
		#		exit $?
		#		;;
		#	*)
		#		exit 0
		#		;;
		#esac
		if [[ $? -eq 1 ]]; then
			$rm "$_iso"
			exit $?
		else
			exit 1
		fi
	fi

	echo_error "There isn't any "ISO" with this name !!!"
	exit 1
	
}

do_mktmpl()
{
	if [[ -z "$1" ]]; then
		echo_usage "mktmpl host [template_name]"
		exit 1
	fi
	check_host ${1}
	check_off ${1}
	load_configfile "${1}"
	
	_basename="$1"
	if [[ ! -z "$2" ]]; then
		_basename="$2"
	fi

	if [[ -f "$bidir/$_basename" ]]; then
		echo_error "there is a template with \"$_basename\" name !!"
		exit 1
	fi

	# Number of virtual disks
	no_vdisk="${#disk[@]}"
	# Number of processed virtual disks
	np_vdisk="0"

	# Find first disk(primary) in complex of disks and cdroms
	for(( i=0; $np_vdisk < $no_vdisk; ++i)); do
		if [[ ${disk[i]-__NULL__} = "__NULL__" ]]; then
			continue;
		fi
		np_vdisk=$(( ++np_vdisk ))

		if [[ ${media[i]} = "disk" &&  ! -z ${disk[i]} ]];  then
			# Check if path is Absolute?
			disk=${disk[i]}
			if [[ $(expr "${disk}" : '/') -eq 0 ]]; then
				disk="${vmstrg}/${disk}"
			fi

			echo_info "Use \"$disk\" disk as base ..."
			# Check if the primary block device exists in the host.
			if [ ! -e ${disk} ]; then
				echo_error "Primary virtual drive (${disk}) doesn't exist or isn't readable."
				exit 1
			fi

			echo_info "Please wait ..."
			"$kvmimg" convert -O qcow2 "${disk}" "$bidir/$_basename"
			_ret="$?"
			if [[ $_ret -eq "0" ]]; then
				echo_result "Template \"$_basename\" been created."
			else 
				echo_error "Can't create template, $( pperror $ret )"
			fi
			exit $ret
		fi
	done
	echo_error "Primary virtual drive doesn't exist."
	exit 1
}

do_rmtmpl()
{
	if [[ -z "$1" ]]; then
		echo_usage "rmtmpl template_name"
		exit 1
	fi

	if [[ ! -f "$bidir/$1" ]]; then
		echo_error "There isn't any base with \"$1\" name !!"
		exit 1
	fi

	echo_info "NOTE: after deleting this base, you can't boot all of"
	echo_info "      your machines that are based on this image !!"
	are_you_sure "Delete \"$1\":"
	if [[ $? -eq "1" ]]; then
		are_you_sure "Again ... ,"
		if [[ $? -eq 1 ]]; then
			$rm "$bidir/$1" >/dev/null 2>&1
			exit $?
		else
			exit 1
		fi
	else
		exit 1
	fi
	#echo -n "Delete \"$1\", Are you sure (y/*)? "
	#read yesno

	#case $yesno in
	#	[yY]*)
	#		echo -n "Again ... , Are you sure (y/*)? "
	#		read yesno
	#		case $yesno in
	#			[yY]*)
	#				$rm -v "$bidir/$1"
	#				exit $?
	#				;;
	#			*)
	#				exit 0
	#				;;
	#		esac
	#;;
	#	*)
	#		exit 0
	#		;;
	#esac

}

do_savevsw()
{
	local vsw_cfg
	vsw_cfg=($@)

	$cat "$cf_virtual_switches" | grep "${vsw_cfg[0]} " >/dev/null 2>&1
	if [[ $? -eq 0 ]]; then
		echo_error "duplicated virtual switches ..."
		exit 1
	fi
	if [[ "${#vsw_cfg[@]}" -lt 4 ]]; then
		echo_error "virtual switch doesn't have enough parameters..!"
		exit 1
	fi

	echo ${vsw_cfg[@]} >> "$cf_virtual_switches"
}

do_unsavevsw()
{
	local vsw
	vsw="$1"
	if [[ ! -z "$vsw" ]]; then
		$sed -i -e "/^$vsw /d" "$cf_virtual_switches" >/dev/null 2>&1 
	fi
}

do_loadvsw()
{
	$basedir/Scripts/make-pvm-vsws add "$1"
}

do_unloadvsw()
{
	$basedir/Scripts/make-pvm-vsws del "$1"
}

do_ver()
{
	echo "$scriptversion"
}

do_usage()
{
	${cat} <<-end-of-help
	${scriptname} ${scriptversion}
	Licensed under BSDL
	Copyright 2010

	${scriptname} is a management and control script for KVM-based virtual machines.

	Usage:  ${scriptname} start    host    - start the named VM

	        ${scriptname} shutdown host    - send shutdown signal to VM
	        ${scriptname} reset    host    - send reset signal to VM

	        ${scriptname} stop     host    - stop  the named VM (only use if the guest is hung)
	        ${scriptname} restart  host    - stop and then start the named VM (only use if the guest is hung)

	        ${scriptname} status           - show the names of all running VMs
	        ${scriptname} status   kvm     - show full details for all running kvm processes
	        ${scriptname} status   host    - show full details for the named kvm process

	        ${scriptname} mkimg    host image_name image_size  - create a disk image 
	        ${scriptname} rmimg    host image_name             - remove disk image of the host
	        ${scriptname} rnimg    host image_name new_name    - rename disk image of the host
	
	        ${scriptname} new      host_name sid               - Create A virtual machine
	        ${scriptname} create   template host_name sid      - Create A virtual machine from template
	        ${scriptname} clone    host clone_name [new_sid]   - creating a clone from the host

	        ${scriptname} rename   host new_name               - rename host to new_name
	        ${scriptname} rmvm     host                        - delete virtual machine
	        ${scriptname} mvvm     host new_sid                - move virtual machine to new storage

	        ${scriptname} edit     host                        - open config file for edit
	        ${scriptname} info     host                        - print out host information (parameters in config file)
	        ${scriptname} chcdrom  host cdrom# iso             - change cdrom for running machines

	        ${scriptname} mktmpl   host  [template_name]       - Create A virtual Template from host
	        ${scriptname} rmtmpl   template_name               - Remove the Virtual Template 
	        ${scriptname} mkiso    iso_name                    - Create An ISO image from the CD in Local CDROM(local)
	        ${scriptname} rmiso    iso_name                    - Remove the ISO image

	        ${scriptname} snaps    host                        - show all snapshots of the host
	        ${scriptname} mksnap   host  [tag|id]              - make an snapshot with [tag|id] if given, or not a new
	        ${scriptname} ldsnap   host   tag|id               - load snapshot with tag|id
	        ${scriptname} rmsnap   host   tag|id               - remove snapshot with tag|id

	        ${scriptname} ls                                   - print out list of virtual machines
	        ${scriptname} lst                                  - print out list of Virtual Templates 
	        ${scriptname} lscd                                 - print out list of CD Images (ISO files)
	        ${scriptname} lsid                                 - print out list of Virtual Storages.

	        ${scriptname} loadvsws                             - load virtual switches and add them to local system.

	        ${scriptname} help                                 - show this usage

	** Using stop is the same as pulling the power cord on a physical system. Use with caution.

	end-of-help
}

# Main script
case "${1}" in
	"start")
		do_start "${2}"
		;;
	"stop")
		do_stop "${2}"
		;;
	"restart")
		do_stop "${2}"
		${sleep} ${sleeptime}
		do_start "${2}"
		;;
	"status")
		do_status "${2}"
		;;
	"pause")
		do_pause "${2}"
		;;
	"resume")
		do_resume "${2}"
		;;
	"vmstatus")
		do_vmstatus "${2}"
		;;
	"create")
		do_create "${2}" "${3}" "$4"
		;;
	"new")
		do_new "$2" "$3"
		;;
	"chcdrom")
		do_chcdrom "$2" "$3" "$4"
		;;
	"shutdown")
		do_shutdown "${2}"
		;;
	"reset")
		do_reset "${2}"
		;;
	"mkimg")
		do_mkimg "${2}" "$3" "$4"
		;;
	"convertimg")
		do_convertimg "${2}" "$3" "$4"
		;;
	"rmimg")
		do_rmimg "${2}" "$3" 
		;;
	"rnimg")
		do_rnimg "$2" "$3" "$4"
		;;
	"snaps")
		do_snaps "${2}"
		;;
	"mksnap")
		do_mksnap "${2}" "${3}"
		;;
	"ldsnap")
		do_ldsnap "${2}" "${3}"
		;;
	"rmsnap")
		do_rmsnap "${2}" "${3}"
		;;
	"genid")
		do_genid
		;;
	"ls")
		do_ls_ids
		;;
	"lst")
		do_lst
		;;
	"lscd")
		do_lscd
		;;
	"lsid")
		do_lsid
		;;
	"mktmpl")
		do_mktmpl "$2" "$3"
		;;
	"mkbase")
		do_mktmpl "$2" "$3"
		;;
	"rmtmpl")
		do_rmtmpl "$2" 
		;;
	"rmbase")
		do_rmtmpl "$2"
		;;
	"mkiso")
		do_mkiso "${2}"
		;;
	"rmiso")
		do_rmiso "${2}"
		;;
	"rmvm")
		do_rmvm ${2}
		;;
	"mvvm")
		do_mvvm "$2" "$3"
		;;
	"rename")
		do_rename ${2} ${3}
		;;
	"clone")
		do_clone ${2} ${3} ${4}
		;;
	"info")
		do_info ${2}
		;;
	"binfo")
		do_binfo ${2}
		;;
	"mon")
		do_mon "${2}"
		;;
	"edit")
		do_edit "${2}"
		;;
	"chconf")
		__i=0
		for __var in "$@"; do
			__ch_args[$__i]=$__var
			__i=$((__i + 1))
		done
		unset __ch_args[0]
		do_chconf "${__ch_args[@]}"
		;;
	"whoami")
		echo $($uname -n)
		;;
	"loadvsws")
		$basedir/Scripts/make-pvm-vsws load
		;;
	"unloadvsws")
		$basedir/Scripts/make-pvm-vsws unload
		;;
	"savevsw")
		__savevsw_args=( $@ )
		unset __savevsw_args[0]
		do_savevsw ${__savevsw_args[@]} 
		;;
	"unsavevsw")
		do_unsavevsw "$2"
		;;
	"loadvsw")
		do_loadvsw "$2"
		;;
	"unloadvsw")
		do_unloadvsw "$2"
		;;
	"delrsite")
		do_delrsite "$2"
		;;
	"addrsite")
		do_addrsite "$2"
		;;
	"choffnode")
		do_choffnode "$2"
		;;
	"ver")
		do_ver
		;;
	"help")
		do_usage
		;;
	*)
		do_usage
		;;
esac

exit 0
